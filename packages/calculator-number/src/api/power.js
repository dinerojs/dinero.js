// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_BigInt from "@rescript/runtime/lib/es6/Stdlib_BigInt.js";
import * as Stdlib_JsError from "@rescript/runtime/lib/es6/Stdlib_JsError.js";

function fromValue(value) {
  if (typeof value !== "number") {
    return {
      NAME: "Float",
      VAL: value
    };
  }
  if (!(value >= 1e15 || value <= -1e15)) {
    if (value === Math.floor(value)) {
      return {
        NAME: "Int",
        VAL: value
      };
    } else {
      return {
        NAME: "Float",
        VAL: value
      };
    }
  }
  let bigintVal = Stdlib_BigInt.fromFloat(value);
  if (bigintVal !== undefined) {
    return {
      NAME: "BigInt",
      VAL: bigintVal
    };
  } else {
    return {
      NAME: "Float",
      VAL: value
    };
  }
}

function powerInt(base, exponent) {
  return Math.pow(base, exponent);
}

function powerFloat(base, exponent) {
  return Math.pow(base, exponent);
}

function powerBigInt(_base, _exponent) {
  while (true) {
    let exponent = _exponent;
    let base = _base;
    if (exponent === 0) {
      return BigInt(1);
    }
    if (exponent === 1) {
      return base;
    }
    if (exponent < 0) {
      return Stdlib_JsError.throwWithMessage("Negative exponents not supported for BigInt");
    }
    if (exponent % 2 === 0) {
      let squared = base * base;
      _exponent = exponent / 2 | 0;
      _base = squared;
      continue;
    }
    let squared$1 = base * base;
    return base * powerBigInt(squared$1, exponent / 2 | 0);
  };
}

function power(base, exponent) {
  let variant = base.NAME;
  if (variant === "Float") {
    if (typeof exponent !== "object") {
      return Stdlib_JsError.throwWithMessage("Invalid base/exponent combination");
    }
    let variant$1 = exponent.NAME;
    let b = base.VAL;
    if (variant$1 === "Int" || variant$1 === "Float") {
      return {
        NAME: "Float",
        VAL: Math.pow(b, exponent.VAL)
      };
    } else {
      return Stdlib_JsError.throwWithMessage("Invalid base/exponent combination");
    }
  }
  if (variant === "BigInt") {
    if (typeof exponent !== "object") {
      return Stdlib_JsError.throwWithMessage("Invalid base/exponent combination");
    }
    let variant$2 = exponent.NAME;
    let b$1 = base.VAL;
    if (variant$2 === "Int") {
      return {
        NAME: "BigInt",
        VAL: powerBigInt(b$1, exponent.VAL)
      };
    } else if (variant$2 === "Float") {
      return {
        NAME: "Float",
        VAL: Math.pow(Number(b$1), exponent.VAL)
      };
    } else {
      return Stdlib_JsError.throwWithMessage("Invalid base/exponent combination");
    }
  }
  if (typeof exponent !== "object") {
    return Stdlib_JsError.throwWithMessage("Invalid base/exponent combination");
  }
  let variant$3 = exponent.NAME;
  let b$2 = base.VAL;
  if (variant$3 === "Int") {
    return {
      NAME: "Int",
      VAL: Math.pow(b$2, exponent.VAL)
    };
  } else if (variant$3 === "Float") {
    return {
      NAME: "Float",
      VAL: Math.pow(b$2, exponent.VAL)
    };
  } else {
    return Stdlib_JsError.throwWithMessage("Invalid base/exponent combination");
  }
}

export {
  fromValue,
  powerInt,
  powerFloat,
  powerBigInt,
  power,
}
/* No side effect */
