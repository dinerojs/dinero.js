// Generated by ReScript, PLEASE EDIT WITH CARE

import * as EqualUtil from "../utils/equalUtil.js";
import * as Distribute from "../utils/distribute.js";
import * as MaximumUtil from "../utils/maximumUtil.js";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Stdlib_JsError from "@rescript/runtime/lib/es6/Stdlib_JsError.js";
import * as TransformScale from "./transformScale.js";
import * as GreaterThanUtil from "../utils/greaterThanUtil.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as GreaterThanOrEqualUtil from "../utils/greaterThanOrEqualUtil.js";

function unsafeAllocate(calculator) {
  let distributeFn = Distribute.distribute(calculator);
  return (dineroObject, ratios) => {
    let match = dineroObject.toJSON();
    let scale = match.scale;
    let currency = match.currency;
    let amounts = ratios.map(ratio => ratio.amount);
    let shares = distributeFn(match.amount, amounts);
    return shares.map(share => dineroObject.create({
      amount: share,
      currency: currency,
      scale: Primitive_option.some(scale)
    }));
  };
}

function safeAllocate(calculator) {
  let allocateFn = unsafeAllocate(calculator);
  let greaterThanOrEqualFn = GreaterThanOrEqualUtil.greaterThanOrEqual(calculator);
  let greaterThanFn = GreaterThanUtil.greaterThan(calculator);
  let convertScaleFn = TransformScale.transformScale(calculator);
  let maximumFn = MaximumUtil.maximum(calculator);
  let equalFn = EqualUtil.equal(calculator);
  let zero = calculator.zero();
  let ten = Stdlib_Array.reduce(Stdlib_Array.make(10, undefined), zero, (acc, param) => calculator.increment(acc));
  return (dineroObject, ratios) => {
    let hasRatios = ratios.length !== 0;
    let highestRatioScale = hasRatios ? maximumFn(ratios.map(ratio => Stdlib_Option.getOr(ratio.scale, zero))) : zero;
    let normalizedRatios = ratios.map(ratio => {
      let scale = Stdlib_Option.getOr(ratio.scale, zero);
      let factor = equalFn(scale, highestRatioScale) ? zero : calculator.subtract(highestRatioScale, scale);
      return {
        amount: calculator.multiply(ratio.amount, calculator.power(ten, factor)),
        scale: Primitive_option.some(scale)
      };
    });
    let hasOnlyPositiveRatios = normalizedRatios.every(ratio => greaterThanOrEqualFn(ratio.amount, zero));
    let hasOneNonZeroRatio = normalizedRatios.some(ratio => greaterThanFn(ratio.amount, zero));
    let condition = hasRatios && hasOnlyPositiveRatios && hasOneNonZeroRatio;
    if (!condition) {
      Stdlib_JsError.throwWithMessage("Invalid ratios.");
    }
    let match = dineroObject.toJSON();
    let newScale = calculator.add(match.scale, highestRatioScale);
    return allocateFn(convertScaleFn(dineroObject, newScale, undefined, undefined), normalizedRatios);
  };
}

export {
  unsafeAllocate,
  safeAllocate,
}
/* No side effect */
