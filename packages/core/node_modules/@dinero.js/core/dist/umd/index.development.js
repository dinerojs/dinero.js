/*! @dinero.js/core 2.0.0-alpha.14 (UNRELEASED 1320a09) | MIT License | Â© Sarah Dayan and contributors | https://v2.dinerojs.com */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@dinero.js/core"] = {}));
})(this, (function (exports) { 'use strict';

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var INVALID_AMOUNT_MESSAGE = 'Amount is invalid.';
  var INVALID_SCALE_MESSAGE = 'Scale is invalid.';
  var INVALID_RATIOS_MESSAGE = 'Ratios are invalid.';
  var UNEQUAL_SCALES_MESSAGE = 'Objects must have the same scale.';
  var UNEQUAL_CURRENCIES_MESSAGE = 'Objects must have the same currency.';
  var NON_DECIMAL_CURRENCY_MESSAGE = 'Currency is not decimal.';

  /* eslint-disable functional/no-throw-statement, valid-jsdoc */
  /**
   * Assert a condition.
   *
   * @param condition - The condition to verify.
   * @param message - The error message to throw.
   *
   * @throws If the condition isn't met.
   */
  function assert(condition, message) {
    if (!condition) {
      throw new Error("[Dinero.js] ".concat(message));
    }
  }

  /* eslint-disable functional/no-mixed-type, functional/no-return-void, functional/no-expression-statement */

  function createDinero(_ref) {
    var calculator = _ref.calculator,
      onCreate = _ref.onCreate,
      _ref$formatter = _ref.formatter,
      formatter = _ref$formatter === void 0 ? {
        toNumber: Number,
        toString: String
      } : _ref$formatter;
    return function dinero(_ref2) {
      var amount = _ref2.amount,
        _ref2$currency = _ref2.currency,
        code = _ref2$currency.code,
        base = _ref2$currency.base,
        exponent = _ref2$currency.exponent,
        _ref2$scale = _ref2.scale,
        scale = _ref2$scale === void 0 ? exponent : _ref2$scale;
      var currency = {
        code: code,
        base: base,
        exponent: exponent
      };
      onCreate === null || onCreate === void 0 ? void 0 : onCreate({
        amount: amount,
        currency: currency,
        scale: scale
      });
      return {
        calculator: calculator,
        formatter: formatter,
        create: dinero,
        toJSON: function toJSON() {
          return {
            amount: amount,
            currency: currency,
            scale: scale
          };
        }
      };
    };
  }

  /* eslint-disable functional/no-mixed-type */

  exports.ComparisonOperator = void 0;
  (function (ComparisonOperator) {
    ComparisonOperator[ComparisonOperator["LT"] = -1] = "LT";
    ComparisonOperator[ComparisonOperator["EQ"] = 0] = "EQ";
    ComparisonOperator[ComparisonOperator["GT"] = 1] = "GT";
  })(exports.ComparisonOperator || (exports.ComparisonOperator = {}));

  /**
   * Returns an equal function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The equal function.
   */
  function equal$1(calculator) {
    return function (subject, comparator) {
      return calculator.compare(subject, comparator) === exports.ComparisonOperator.EQ;
    };
  }

  /**
   * Returns a lessThan function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The lessThan function.
   */
  function lessThan(calculator) {
    return function (subject, comparator) {
      return calculator.compare(subject, comparator) === exports.ComparisonOperator.LT;
    };
  }

  function absolute(calculator) {
    var equalFn = equal$1(calculator);
    var lessThanFn = lessThan(calculator);
    var zero = calculator.zero();
    return function (input) {
      if (equalFn(input, zero)) {
        return zero;
      }
      if (lessThanFn(input, zero)) {
        var minusOne = calculator.decrement(zero);
        return calculator.multiply(minusOne, input);
      }
      return input;
    };
  }

  /**
   * Returns a compare function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The compare function.
   */
  function compare(calculator) {
    return function (subject, comparator) {
      return calculator.compare(subject, comparator);
    };
  }

  function isArray(maybeArray) {
    return Array.isArray(maybeArray);
  }

  function computeBase(calculator) {
    return function (base) {
      if (isArray(base)) {
        return base.reduce(function (acc, curr) {
          return calculator.multiply(acc, curr);
        });
      }
      return base;
    };
  }

  /* eslint-disable functional/no-let, functional/no-loop-statement, functional/no-expression-statement */
  function countTrailingZeros(calculator) {
    var equalFn = equal$1(calculator);
    return function (input, base) {
      var zero = calculator.zero();
      if (equalFn(zero, input)) {
        return calculator.zero();
      }
      var i = zero;
      var temp = input;
      while (equalFn(calculator.modulo(temp, base), zero)) {
        temp = calculator.integerDivide(temp, base);
        i = calculator.increment(i);
      }
      return i;
    };
  }

  /**
   * Returns a greaterThan function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The greaterThan function.
   */
  function greaterThan(calculator) {
    return function (subject, comparator) {
      return calculator.compare(subject, comparator) === exports.ComparisonOperator.GT;
    };
  }

  /**
   * Returns a greaterThanOrEqual function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The greaterThanOrEqual function.
   */
  function greaterThanOrEqual(calculator) {
    return function (subject, comparator) {
      return greaterThan(calculator)(subject, comparator) || equal$1(calculator)(subject, comparator);
    };
  }

  /* eslint-disable functional/no-let, functional/no-loop-statement, functional/immutable-data, functional/no-expression-statement */
  /**
   * Returns a distribute function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The distribute function.
   */
  function distribute(calculator) {
    return function (value, ratios) {
      var equalFn = equal$1(calculator);
      var greaterThanFn = greaterThan(calculator);
      var lessThanFn = lessThan(calculator);
      var greaterThanOrEqualFn = greaterThanOrEqual(calculator);
      var zero = calculator.zero();
      var one = calculator.increment(zero);
      var total = ratios.reduce(function (a, b) {
        return calculator.add(a, b);
      }, zero);
      if (equalFn(total, zero)) {
        return ratios;
      }
      var remainder = value;
      var shares = ratios.map(function (ratio) {
        var share = calculator.integerDivide(calculator.multiply(value, ratio), total) || zero;
        remainder = calculator.subtract(remainder, share);
        return share;
      });
      var isPositive = greaterThanOrEqualFn(value, zero);
      var compare = isPositive ? greaterThanFn : lessThanFn;
      var amount = isPositive ? one : calculator.decrement(zero);
      var i = 0;
      while (compare(remainder, zero)) {
        if (!equalFn(ratios[i], zero)) {
          shares[i] = calculator.add(shares[i], amount);
          remainder = calculator.subtract(remainder, amount);
        }
        i++;
      }
      return shares;
    };
  }

  function isScaledAmount(amount) {
    return amount === null || amount === void 0 ? void 0 : amount.hasOwnProperty('amount');
  }

  function getAmountAndScale(value, zero) {
    if (isScaledAmount(value)) {
      var _value$scale;
      return {
        amount: value.amount,
        scale: (_value$scale = value === null || value === void 0 ? void 0 : value.scale) !== null && _value$scale !== void 0 ? _value$scale : zero
      };
    }
    return {
      amount: value,
      scale: zero
    };
  }

  function getDivisors(calculator) {
    var multiply = calculator.multiply;
    return function (bases) {
      return bases.reduce(function (divisors, _, i) {
        var divisor = bases.slice(i).reduce(function (acc, curr) {
          return multiply(acc, curr);
        });
        return [].concat(_toConsumableArray(divisors), [divisor]);
      }, []);
    };
  }

  function isEven(calculator) {
    var equalFn = equal$1(calculator);
    var zero = calculator.zero();
    var two = calculator.increment(calculator.increment(zero));
    return function (input) {
      return equalFn(calculator.modulo(input, two), zero);
    };
  }

  function isHalf(calculator) {
    var equalFn = equal$1(calculator);
    var absoluteFn = absolute(calculator);
    return function (input, total) {
      var remainder = absoluteFn(calculator.modulo(input, total));
      var difference = calculator.subtract(total, remainder);
      return equalFn(difference, remainder);
    };
  }

  /**
   * Returns a lessThanOrEqual function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The lessThanOrEqual function.
   */
  function lessThanOrEqual(calculator) {
    return function (subject, comparator) {
      return lessThan(calculator)(subject, comparator) || equal$1(calculator)(subject, comparator);
    };
  }

  /**
   * Returns a maximum function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The maximum function.
   */
  function maximum(calculator) {
    var lessThanFn = lessThan(calculator);
    return function (values) {
      return values.reduce(function (acc, curr) {
        return lessThanFn(acc, curr) ? curr : acc;
      });
    };
  }

  /**
   * Returns a minimum function.
   *
   * @param calculator - The calculator to use.
   *
   * @returns The minimum function.
   */
  function minimum(calculator) {
    var greaterThanFn = greaterThan(calculator);
    return function (values) {
      return values.reduce(function (acc, curr) {
        return greaterThanFn(acc, curr) ? curr : acc;
      });
    };
  }

  function sign(calculator) {
    var equalFn = equal$1(calculator);
    var lessThanFn = lessThan(calculator);
    var zero = calculator.zero();
    return function (input) {
      if (equalFn(input, zero)) {
        return zero;
      }
      var one = calculator.increment(zero);
      var minusOne = calculator.decrement(zero);
      return lessThanFn(input, zero) ? minusOne : one;
    };
  }

  function haveSameCurrency(dineroObjects) {
    var _dineroObjects = _toArray(dineroObjects),
      firstDinero = _dineroObjects[0],
      otherDineros = _dineroObjects.slice(1);
    var computeBaseFn = computeBase(firstDinero.calculator);
    var _firstDinero$toJSON = firstDinero.toJSON(),
      comparator = _firstDinero$toJSON.currency;
    var equalFn = equal$1(firstDinero.calculator);
    var comparatorBase = computeBaseFn(comparator.base);
    return otherDineros.every(function (d) {
      var _d$toJSON = d.toJSON(),
        subject = _d$toJSON.currency;
      var subjectBase = computeBaseFn(subject.base);
      return subject.code === comparator.code && equalFn(subjectBase, comparatorBase) && equalFn(subject.exponent, comparator.exponent);
    });
  }

  /**
   * Divide and round down.
   *
   * Rounding down happens whenever the quotient is not an integer.
   *
   * @param amount - The amount to divide.
   * @param factor - The factor to divide by.
   * @param calculator - The calculator to use.
   *
   * @returns The rounded amount.
   */
  var down = function down(amount, factor, calculator) {
    var greaterThanFn = greaterThan(calculator);
    var equalFn = equal$1(calculator);
    var zero = calculator.zero();
    var isPositive = greaterThanFn(amount, zero);
    var quotient = calculator.integerDivide(amount, factor);
    var remainder = calculator.modulo(amount, factor);
    var isInteger = equalFn(remainder, zero);
    if (isPositive || isInteger) {
      return quotient;
    }
    return calculator.decrement(quotient);
  };

  /**
   * Divide and round towards "nearest neighbor" unless both neighbors are
   * equidistant, in which case round away from zero.
   *
   * @param amount - The amount to divide.
   * @param factor - The factor to divide by.
   * @param calculator - The calculator to use.
   *
   * @returns The rounded amount.
   */
  var halfAwayFromZero = function halfAwayFromZero(amount, factor, calculator) {
    var signFn = sign(calculator);
    var isHalfFn = isHalf(calculator);
    var absoluteFn = absolute(calculator);
    if (!isHalfFn(amount, factor)) {
      return halfUp(amount, factor, calculator);
    }
    return calculator.multiply(signFn(amount), up(absoluteFn(amount), factor, calculator));
  };

  /**
   * Divide and round towards "nearest neighbor" unless both neighbors are
   * equidistant, in which case round down.
   *
   * Rounding down happens when:
   * - The quotient is half (e.g., -1.5, 1.5).
   * - The quotient is positive and less than half (e.g., 1.4).
   * - The quotient is negative and greater than half (e.g., -1.6).
   *
   * @param amount - The amount to divide.
   * @param factor - The factor to divide by.
   * @param calculator - The calculator to use.
   *
   * @returns The rounded amount.
   */
  var halfDown = function halfDown(amount, factor, calculator) {
    var isHalfFn = isHalf(calculator);
    if (isHalfFn(amount, factor)) {
      return down(amount, factor, calculator);
    }
    return halfUp(amount, factor, calculator);
  };

  /**
   * Divide and round towards "nearest neighbor" unless both neighbors are
   * equidistant, in which case round to the nearest even integer.
   *
   * @param amount - The amount to divide.
   * @param factor - The factor to divide by.
   * @param calculator - The calculator to use.
   *
   * @returns The rounded amount.
   */
  var halfEven = function halfEven(amount, factor, calculator) {
    var isEvenFn = isEven(calculator);
    var isHalfFn = isHalf(calculator);
    var rounded = halfUp(amount, factor, calculator);
    if (!isHalfFn(amount, factor)) {
      return rounded;
    }
    return isEvenFn(rounded) ? rounded : calculator.decrement(rounded);
  };

  /**
   * Divide and round towards "nearest neighbor" unless both neighbors are
   * equidistant, in which case round to the nearest odd integer.
   *
   * @param amount - The amount to divide.
   * @param factor - The factor to divide by.
   * @param calculator - The calculator to use.
   *
   * @returns The rounded amount.
   */
  var halfOdd = function halfOdd(amount, factor, calculator) {
    var isEvenFn = isEven(calculator);
    var isHalfFn = isHalf(calculator);
    var rounded = halfUp(amount, factor, calculator);
    if (!isHalfFn(amount, factor)) {
      return rounded;
    }
    return isEvenFn(rounded) ? calculator.decrement(rounded) : rounded;
  };

  /**
   * Divide and round towards "nearest neighbor" unless both neighbors are
   * equidistant, in which case round towards zero.
   *
   * @param amount - The amount to divide.
   * @param factor - The factor to divide by.
   * @param calculator - The calculator to use.
   *
   * @returns The rounded amount.
   */
  var halfTowardsZero = function halfTowardsZero(amount, factor, calculator) {
    var signFn = sign(calculator);
    var isHalfFn = isHalf(calculator);
    var absoluteFn = absolute(calculator);
    if (!isHalfFn(amount, factor)) {
      return halfUp(amount, factor, calculator);
    }
    return calculator.multiply(signFn(amount), down(absoluteFn(amount), factor, calculator));
  };

  /**
   * Divide and round towards "nearest neighbor" unless both neighbors are
   * equidistant, in which case round up.
   *
   * Rounding up happens when:
   * - The quotient is half (e.g., -1.5, 1.5).
   * - The quotient is positive and greater than half (e.g., 1.6).
   * - The quotient is negative and less than half (e.g., -1.4).
   *
   * @param amount - The amount to divide.
   * @param factor - The factor to divide by.
   * @param calculator - The calculator to use.
   *
   * @returns The rounded amount.
   */
  var halfUp = function halfUp(amount, factor, calculator) {
    var greaterThanFn = greaterThan(calculator);
    var isHalfFn = isHalf(calculator);
    var absoluteFn = absolute(calculator);
    var zero = calculator.zero();
    var remainder = absoluteFn(calculator.modulo(amount, factor));
    var difference = calculator.subtract(factor, remainder);
    var isLessThanHalf = greaterThanFn(difference, remainder);
    var isPositive = greaterThanFn(amount, zero);
    if (isHalfFn(amount, factor) || isPositive && !isLessThanHalf || !isPositive && isLessThanHalf) {
      return up(amount, factor, calculator);
    }
    return down(amount, factor, calculator);
  };

  /**
   * Divide and round up.
   *
   * Rounding up happens whenever the quotient is not an integer.
   *
   * @param amount - The amount to divide.
   * @param factor - The factor to divide by.
   * @param calculator - The calculator to use.
   *
   * @returns The rounded amount.
   */
  var up = function up(amount, factor, calculator) {
    var greaterThanFn = greaterThan(calculator);
    var equalFn = equal$1(calculator);
    var zero = calculator.zero();
    var isPositive = greaterThanFn(amount, zero);
    var quotient = calculator.integerDivide(amount, factor);
    var remainder = calculator.modulo(amount, factor);
    var isInteger = equalFn(remainder, zero);
    if (!isInteger && isPositive) {
      return calculator.increment(quotient);
    }
    return quotient;
  };

  function transformScale(calculator) {
    var greaterThanFn = greaterThan(calculator);
    var computeBaseFn = computeBase(calculator);
    return function transformScaleFn() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        newScale = _ref[1],
        _ref$ = _ref[2],
        divide = _ref$ === void 0 ? down : _ref$;
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount,
        currency = _dineroObject$toJSON.currency,
        scale = _dineroObject$toJSON.scale;
      var isLarger = greaterThanFn(newScale, scale);
      var operation = isLarger ? calculator.multiply : divide;
      var _ref2 = isLarger ? [newScale, scale] : [scale, newScale],
        _ref3 = _slicedToArray(_ref2, 2),
        a = _ref3[0],
        b = _ref3[1];
      var base = computeBaseFn(currency.base);
      var factor = calculator.power(base, calculator.subtract(a, b));
      return dineroObject.create({
        amount: operation(amount, factor, calculator),
        currency: currency,
        scale: newScale
      });
    };
  }

  function normalizeScale(calculator) {
    var maximumFn = maximum(calculator);
    var convertScaleFn = transformScale(calculator);
    var equalFn = equal$1(calculator);
    return function _normalizeScale() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObjects = _ref[0];
      var highestScale = dineroObjects.reduce(function (highest, current) {
        var _current$toJSON = current.toJSON(),
          scale = _current$toJSON.scale;
        return maximumFn([highest, scale]);
      }, calculator.zero());
      return dineroObjects.map(function (d) {
        var _d$toJSON = d.toJSON(),
          scale = _d$toJSON.scale;
        return !equalFn(scale, highestScale) ? convertScaleFn(d, highestScale) : d;
      });
    };
  }

  function unsafeAdd(calculator) {
    return function add() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var augend = _ref[0],
        addend = _ref[1];
      var _augend$toJSON = augend.toJSON(),
        augendAmount = _augend$toJSON.amount,
        currency = _augend$toJSON.currency,
        scale = _augend$toJSON.scale;
      var _addend$toJSON = addend.toJSON(),
        addendAmount = _addend$toJSON.amount;
      var amount = calculator.add(augendAmount, addendAmount);
      return augend.create({
        amount: amount,
        currency: currency,
        scale: scale
      });
    };
  }
  function safeAdd(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var addFn = unsafeAdd(calculator);
    return function add() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var augend = _ref2[0],
        addend = _ref2[1];
      var condition = haveSameCurrency([augend, addend]);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var _normalizeFn = normalizeFn([augend, addend]),
        _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
        newAugend = _normalizeFn2[0],
        newAddend = _normalizeFn2[1];
      return addFn(newAugend, newAddend);
    };
  }

  /* eslint-disable functional/no-expression-statement */
  function unsafeAllocate(calculator) {
    return function allocate() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        ratios = _ref[1];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount,
        currency = _dineroObject$toJSON.currency,
        scale = _dineroObject$toJSON.scale;
      var distributeFn = distribute(calculator);
      var shares = distributeFn(amount, ratios.map(function (ratio) {
        return ratio.amount;
      }));
      return shares.map(function (share) {
        return dineroObject.create({
          amount: share,
          currency: currency,
          scale: scale
        });
      });
    };
  }
  function safeAllocate(calculator) {
    var allocateFn = unsafeAllocate(calculator);
    var greaterThanOrEqualFn = greaterThanOrEqual(calculator);
    var greaterThanFn = greaterThan(calculator);
    var convertScaleFn = transformScale(calculator);
    var maximumFn = maximum(calculator);
    var equalFn = equal$1(calculator);
    var zero = calculator.zero();
    var ten = new Array(10).fill(null).reduce(calculator.increment, zero);
    return function allocate() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var dineroObject = _ref2[0],
        ratios = _ref2[1];
      var hasRatios = ratios.length > 0;
      var scaledRatios = ratios.map(function (ratio) {
        return getAmountAndScale(ratio, zero);
      });
      var highestRatioScale = hasRatios ? maximumFn(scaledRatios.map(function (_ref3) {
        var scale = _ref3.scale;
        return scale;
      })) : zero;
      var normalizedRatios = scaledRatios.map(function (_ref4) {
        var amount = _ref4.amount,
          scale = _ref4.scale;
        var factor = equalFn(scale, highestRatioScale) ? zero : calculator.subtract(highestRatioScale, scale);
        return {
          amount: calculator.multiply(amount, calculator.power(ten, factor)),
          scale: scale
        };
      });
      var hasOnlyPositiveRatios = normalizedRatios.every(function (_ref5) {
        var amount = _ref5.amount;
        return greaterThanOrEqualFn(amount, zero);
      });
      var hasOneNonZeroRatio = normalizedRatios.some(function (_ref6) {
        var amount = _ref6.amount;
        return greaterThanFn(amount, zero);
      });
      var condition = hasRatios && hasOnlyPositiveRatios && hasOneNonZeroRatio;
      assert(condition, INVALID_RATIOS_MESSAGE);
      var _dineroObject$toJSON2 = dineroObject.toJSON(),
        scale = _dineroObject$toJSON2.scale;
      var newScale = calculator.add(scale, highestRatioScale);
      return allocateFn(convertScaleFn(dineroObject, newScale), normalizedRatios);
    };
  }

  function unsafeCompare(calculator) {
    var compareFn = compare(calculator);
    return function compare() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        comparator = _ref[1];
      var dineroObjects = [dineroObject, comparator];
      var _dineroObjects$map = dineroObjects.map(function (d) {
          var _d$toJSON = d.toJSON(),
            amount = _d$toJSON.amount;
          return amount;
        }),
        _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
        subjectAmount = _dineroObjects$map2[0],
        comparatorAmount = _dineroObjects$map2[1];
      return compareFn(subjectAmount, comparatorAmount);
    };
  }
  function safeCompare(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var compareFn = unsafeCompare(calculator);
    return function compare() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var dineroObject = _ref2[0],
        comparator = _ref2[1];
      var condition = haveSameCurrency([dineroObject, comparator]);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var _normalizeFn = normalizeFn([dineroObject, comparator]),
        _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
        subjectAmount = _normalizeFn2[0],
        comparatorAmount = _normalizeFn2[1];
      return compareFn(subjectAmount, comparatorAmount);
    };
  }

  function convert(calculator) {
    var convertScaleFn = transformScale(calculator);
    var maximumFn = maximum(calculator);
    var zero = calculator.zero();
    return function convertFn() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        newCurrency = _ref[1],
        rates = _ref[2];
      var rate = rates[newCurrency.code];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount,
        scale = _dineroObject$toJSON.scale;
      var _getAmountAndScale = getAmountAndScale(rate, zero),
        rateAmount = _getAmountAndScale.amount,
        rateScale = _getAmountAndScale.scale;
      var newScale = calculator.add(scale, rateScale);
      return convertScaleFn(dineroObject.create({
        amount: calculator.multiply(amount, rateAmount),
        currency: newCurrency,
        scale: newScale
      }), maximumFn([newScale, newCurrency.exponent]));
    };
  }

  function haveSameAmount(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var equalFn = equal$1(calculator);
    return function _haveSameAmount() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObjects = _ref[0];
      var _normalizeFn = normalizeFn(dineroObjects),
        _normalizeFn2 = _toArray(_normalizeFn),
        firstDinero = _normalizeFn2[0],
        otherDineros = _normalizeFn2.slice(1);
      var _firstDinero$toJSON = firstDinero.toJSON(),
        comparatorAmount = _firstDinero$toJSON.amount;
      return otherDineros.every(function (d) {
        var _d$toJSON = d.toJSON(),
          subjectAmount = _d$toJSON.amount;
        return equalFn(subjectAmount, comparatorAmount);
      });
    };
  }

  function equal(calculator) {
    return function _equal() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        comparator = _ref[1];
      return haveSameAmount(calculator)([dineroObject, comparator]) && haveSameCurrency([dineroObject, comparator]);
    };
  }

  function unsafeGreaterThan(calculator) {
    var greaterThanFn = greaterThan(calculator);
    return function greaterThan() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        comparator = _ref[1];
      var dineroObjects = [dineroObject, comparator];
      var _dineroObjects$map = dineroObjects.map(function (d) {
          var _d$toJSON = d.toJSON(),
            amount = _d$toJSON.amount;
          return amount;
        }),
        _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
        subjectAmount = _dineroObjects$map2[0],
        comparatorAmount = _dineroObjects$map2[1];
      return greaterThanFn(subjectAmount, comparatorAmount);
    };
  }
  function safeGreaterThan(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var greaterThanFn = unsafeGreaterThan(calculator);
    return function greaterThan() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var dineroObject = _ref2[0],
        comparator = _ref2[1];
      var condition = haveSameCurrency([dineroObject, comparator]);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var _normalizeFn = normalizeFn([dineroObject, comparator]),
        _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
        subjectAmount = _normalizeFn2[0],
        comparatorAmount = _normalizeFn2[1];
      return greaterThanFn(subjectAmount, comparatorAmount);
    };
  }

  function unsafeGreaterThanOrEqual(calculator) {
    var greaterThanOrEqualFn = greaterThanOrEqual(calculator);
    return function greaterThanOrEqual() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        comparator = _ref[1];
      var dineroObjects = [dineroObject, comparator];
      var _dineroObjects$map = dineroObjects.map(function (d) {
          var _d$toJSON = d.toJSON(),
            amount = _d$toJSON.amount;
          return amount;
        }),
        _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
        subjectAmount = _dineroObjects$map2[0],
        comparatorAmount = _dineroObjects$map2[1];
      return greaterThanOrEqualFn(subjectAmount, comparatorAmount);
    };
  }
  function safeGreaterThanOrEqual(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var greaterThanOrEqualFn = unsafeGreaterThanOrEqual(calculator);
    return function greaterThanOrEqual() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var dineroObject = _ref2[0],
        comparator = _ref2[1];
      var condition = haveSameCurrency([dineroObject, comparator]);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var _normalizeFn = normalizeFn([dineroObject, comparator]),
        _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
        subjectAmount = _normalizeFn2[0],
        comparatorAmount = _normalizeFn2[1];
      return greaterThanOrEqualFn(subjectAmount, comparatorAmount);
    };
  }

  function hasSubUnits(calculator) {
    var equalFn = equal$1(calculator);
    var computeBaseFn = computeBase(calculator);
    return function _hasSubUnits() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount,
        currency = _dineroObject$toJSON.currency,
        scale = _dineroObject$toJSON.scale;
      var base = computeBaseFn(currency.base);
      return !equalFn(calculator.modulo(amount, calculator.power(base, scale)), calculator.zero());
    };
  }

  function isNegative(calculator) {
    var lessThanFn = lessThan(calculator);
    return function _isNegative() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount;
      return lessThanFn(amount, calculator.zero());
    };
  }

  function isPositive(calculator) {
    var greaterThanFn = greaterThan(calculator);
    return function _isPositive() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount;
      return greaterThanFn(amount, calculator.zero());
    };
  }

  function isZero(calculator) {
    var equalFn = equal$1(calculator);
    return function _isZero() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount;
      return equalFn(amount, calculator.zero());
    };
  }

  function unsafeLessThan(calculator) {
    var lessThanFn = lessThan(calculator);
    return function lessThan() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        comparator = _ref[1];
      var dineroObjects = [dineroObject, comparator];
      var _dineroObjects$map = dineroObjects.map(function (d) {
          var _d$toJSON = d.toJSON(),
            amount = _d$toJSON.amount;
          return amount;
        }),
        _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
        subjectAmount = _dineroObjects$map2[0],
        comparatorAmount = _dineroObjects$map2[1];
      return lessThanFn(subjectAmount, comparatorAmount);
    };
  }
  function safeLessThan(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var lessThanFn = unsafeLessThan(calculator);
    return function lessThan() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var dineroObject = _ref2[0],
        comparator = _ref2[1];
      var condition = haveSameCurrency([dineroObject, comparator]);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var _normalizeFn = normalizeFn([dineroObject, comparator]),
        _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
        subjectAmount = _normalizeFn2[0],
        comparatorAmount = _normalizeFn2[1];
      return lessThanFn(subjectAmount, comparatorAmount);
    };
  }

  function unsafeLessThanOrEqual(calculator) {
    var lessThanOrEqualFn = lessThanOrEqual(calculator);
    return function lessThanOrEqual() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        comparator = _ref[1];
      var dineroObjects = [dineroObject, comparator];
      var _dineroObjects$map = dineroObjects.map(function (d) {
          var _d$toJSON = d.toJSON(),
            amount = _d$toJSON.amount;
          return amount;
        }),
        _dineroObjects$map2 = _slicedToArray(_dineroObjects$map, 2),
        subjectAmount = _dineroObjects$map2[0],
        comparatorAmount = _dineroObjects$map2[1];
      return lessThanOrEqualFn(subjectAmount, comparatorAmount);
    };
  }
  function safeLessThanOrEqual(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var lessThanOrEqualFn = unsafeLessThanOrEqual(calculator);
    return function lessThanOrEqual() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var dineroObject = _ref2[0],
        comparator = _ref2[1];
      var condition = haveSameCurrency([dineroObject, comparator]);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var _normalizeFn = normalizeFn([dineroObject, comparator]),
        _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
        subjectAmount = _normalizeFn2[0],
        comparatorAmount = _normalizeFn2[1];
      return lessThanOrEqualFn(subjectAmount, comparatorAmount);
    };
  }

  function unsafeMaximum(calculator) {
    var maxFn = maximum(calculator);
    return function maximum() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObjects = _ref[0];
      var _dineroObjects = _slicedToArray(dineroObjects, 1),
        firstDinero = _dineroObjects[0];
      var _firstDinero$toJSON = firstDinero.toJSON(),
        currency = _firstDinero$toJSON.currency,
        scale = _firstDinero$toJSON.scale;
      var amount = maxFn(dineroObjects.map(function (subject) {
        var _subject$toJSON = subject.toJSON(),
          subjectAmount = _subject$toJSON.amount;
        return subjectAmount;
      }));
      return firstDinero.create({
        amount: amount,
        currency: currency,
        scale: scale
      });
    };
  }
  function safeMaximum(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var maxFn = unsafeMaximum(calculator);
    return function maximum() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var dineroObjects = _ref2[0];
      var condition = haveSameCurrency(dineroObjects);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var normalizedDineroObjects = normalizeFn(dineroObjects);
      return maxFn(normalizedDineroObjects);
    };
  }

  function unsafeMinimum(calculator) {
    var minFn = minimum(calculator);
    return function minimum() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObjects = _ref[0];
      var _dineroObjects = _slicedToArray(dineroObjects, 1),
        firstDinero = _dineroObjects[0];
      var _firstDinero$toJSON = firstDinero.toJSON(),
        currency = _firstDinero$toJSON.currency,
        scale = _firstDinero$toJSON.scale;
      var amount = minFn(dineroObjects.map(function (subject) {
        var _subject$toJSON = subject.toJSON(),
          subjectAmount = _subject$toJSON.amount;
        return subjectAmount;
      }));
      return firstDinero.create({
        amount: amount,
        currency: currency,
        scale: scale
      });
    };
  }
  function safeMinimum(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var minFn = unsafeMinimum(calculator);
    return function maximum() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var dineroObjects = _ref2[0];
      var condition = haveSameCurrency(dineroObjects);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var normalizedDineroObjects = normalizeFn(dineroObjects);
      return minFn(normalizedDineroObjects);
    };
  }

  function multiply(calculator) {
    var convertScaleFn = transformScale(calculator);
    var zero = calculator.zero();
    return function multiplyFn() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var multiplicand = _ref[0],
        multiplier = _ref[1];
      var _multiplicand$toJSON = multiplicand.toJSON(),
        amount = _multiplicand$toJSON.amount,
        currency = _multiplicand$toJSON.currency,
        scale = _multiplicand$toJSON.scale;
      var _getAmountAndScale = getAmountAndScale(multiplier, zero),
        multiplierAmount = _getAmountAndScale.amount,
        multiplierScale = _getAmountAndScale.scale;
      var newScale = calculator.add(scale, multiplierScale);
      return convertScaleFn(multiplicand.create({
        amount: calculator.multiply(amount, multiplierAmount),
        currency: currency,
        scale: newScale
      }), newScale);
    };
  }

  function unsafeSubtract(calculator) {
    return function subtract() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var minuend = _ref[0],
        subtrahend = _ref[1];
      var _minuend$toJSON = minuend.toJSON(),
        minuendAmount = _minuend$toJSON.amount,
        currency = _minuend$toJSON.currency,
        scale = _minuend$toJSON.scale;
      var _subtrahend$toJSON = subtrahend.toJSON(),
        subtrahendAmount = _subtrahend$toJSON.amount;
      var amount = calculator.subtract(minuendAmount, subtrahendAmount);
      return minuend.create({
        amount: amount,
        currency: currency,
        scale: scale
      });
    };
  }
  function safeSubtract(calculator) {
    var normalizeFn = normalizeScale(calculator);
    var subtractFn = unsafeSubtract(calculator);
    return function subtract() {
      for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref2[_key2] = arguments[_key2];
      }
      var minuend = _ref2[0],
        subtrahend = _ref2[1];
      var condition = haveSameCurrency([minuend, subtrahend]);
      assert(condition, UNEQUAL_CURRENCIES_MESSAGE);
      var _normalizeFn = normalizeFn([minuend, subtrahend]),
        _normalizeFn2 = _slicedToArray(_normalizeFn, 2),
        newMinuend = _normalizeFn2[0],
        newSubtrahend = _normalizeFn2[1];
      return subtractFn(newMinuend, newSubtrahend);
    };
  }

  function toUnits(calculator) {
    var getDivisorsFn = getDivisors(calculator);
    return function toUnitsFn() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        transformer = _ref[1];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount,
        currency = _dineroObject$toJSON.currency,
        scale = _dineroObject$toJSON.scale;
      var power = calculator.power,
        integerDivide = calculator.integerDivide,
        modulo = calculator.modulo;
      var bases = isArray(currency.base) ? currency.base : [currency.base];
      var divisors = getDivisorsFn(bases.map(function (base) {
        return power(base, scale);
      }));
      var value = divisors.reduce(function (amounts, divisor, index) {
        var amountLeft = amounts[index];
        var quotient = integerDivide(amountLeft, divisor);
        var remainder = modulo(amountLeft, divisor);
        return [].concat(_toConsumableArray(amounts.filter(function (_, i) {
          return i !== index;
        })), [quotient, remainder]);
      }, [amount]);
      if (!transformer) {
        return value;
      }
      return transformer({
        value: value,
        currency: currency
      });
    };
  }

  function toDecimal(calculator) {
    var toUnitsFn = toUnits(calculator);
    var computeBaseFn = computeBase(calculator);
    var equalFn = equal$1(calculator);
    return function toDecimalFn() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0],
        transformer = _ref[1];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        currency = _dineroObject$toJSON.currency,
        scale = _dineroObject$toJSON.scale;
      var base = computeBaseFn(currency.base);
      var zero = calculator.zero();
      var ten = new Array(10).fill(null).reduce(calculator.increment, zero);
      var isMultiBase = isArray(currency.base);
      var isBaseTen = equalFn(calculator.modulo(base, ten), zero);
      var isDecimal = !isMultiBase && isBaseTen;

      // eslint-disable-next-line functional/no-expression-statement
      assert(isDecimal, NON_DECIMAL_CURRENCY_MESSAGE);
      var units = toUnitsFn(dineroObject);
      var getDecimalFn = getDecimal(calculator, dineroObject.formatter);
      var value = getDecimalFn(units, scale);
      if (!transformer) {
        return value;
      }
      return transformer({
        value: value,
        currency: currency
      });
    };
  }
  function getDecimal(calculator, formatter) {
    var absoluteFn = absolute(calculator);
    var equalFn = equal$1(calculator);
    var lessThanFn = lessThan(calculator);
    var zero = calculator.zero();
    return function (units, scale) {
      var whole = formatter.toString(units[0]);
      var fractional = formatter.toString(absoluteFn(units[1]));
      var scaleNumber = formatter.toNumber(scale);
      var decimal = "".concat(whole, ".").concat(fractional.padStart(scaleNumber, '0'));
      var leadsWithZero = equalFn(units[0], zero);
      var isNegative = lessThanFn(units[1], zero);

      // A leading negative zero is a special case because the `toString`
      // formatter won't preserve its negative sign (since 0 === -0).
      return leadsWithZero && isNegative ? "-".concat(decimal) : decimal;
    };
  }

  function toSnapshot(dineroObject) {
    return dineroObject.toJSON();
  }

  function trimScale(calculator) {
    var countTrailingZerosFn = countTrailingZeros(calculator);
    var equalFn = equal$1(calculator);
    var maximumFn = maximum(calculator);
    var transformScaleFn = transformScale(calculator);
    var computeBaseFn = computeBase(calculator);
    return function trimScaleFn() {
      for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref[_key] = arguments[_key];
      }
      var dineroObject = _ref[0];
      var _dineroObject$toJSON = dineroObject.toJSON(),
        amount = _dineroObject$toJSON.amount,
        currency = _dineroObject$toJSON.currency,
        scale = _dineroObject$toJSON.scale;
      var base = computeBaseFn(currency.base);
      var trailingZerosLength = countTrailingZerosFn(amount, base);
      var difference = calculator.subtract(scale, trailingZerosLength);
      var newScale = maximumFn([difference, currency.exponent]);
      if (equalFn(newScale, scale)) {
        return dineroObject;
      }
      return transformScaleFn(dineroObject, newScale);
    };
  }

  exports.INVALID_AMOUNT_MESSAGE = INVALID_AMOUNT_MESSAGE;
  exports.INVALID_RATIOS_MESSAGE = INVALID_RATIOS_MESSAGE;
  exports.INVALID_SCALE_MESSAGE = INVALID_SCALE_MESSAGE;
  exports.NON_DECIMAL_CURRENCY_MESSAGE = NON_DECIMAL_CURRENCY_MESSAGE;
  exports.UNEQUAL_CURRENCIES_MESSAGE = UNEQUAL_CURRENCIES_MESSAGE;
  exports.UNEQUAL_SCALES_MESSAGE = UNEQUAL_SCALES_MESSAGE;
  exports.assert = assert;
  exports.convert = convert;
  exports.createDinero = createDinero;
  exports.down = down;
  exports.equal = equal;
  exports.halfAwayFromZero = halfAwayFromZero;
  exports.halfDown = halfDown;
  exports.halfEven = halfEven;
  exports.halfOdd = halfOdd;
  exports.halfTowardsZero = halfTowardsZero;
  exports.halfUp = halfUp;
  exports.hasSubUnits = hasSubUnits;
  exports.haveSameAmount = haveSameAmount;
  exports.haveSameCurrency = haveSameCurrency;
  exports.isNegative = isNegative;
  exports.isPositive = isPositive;
  exports.isZero = isZero;
  exports.multiply = multiply;
  exports.normalizeScale = normalizeScale;
  exports.safeAdd = safeAdd;
  exports.safeAllocate = safeAllocate;
  exports.safeCompare = safeCompare;
  exports.safeGreaterThan = safeGreaterThan;
  exports.safeGreaterThanOrEqual = safeGreaterThanOrEqual;
  exports.safeLessThan = safeLessThan;
  exports.safeLessThanOrEqual = safeLessThanOrEqual;
  exports.safeMaximum = safeMaximum;
  exports.safeMinimum = safeMinimum;
  exports.safeSubtract = safeSubtract;
  exports.toDecimal = toDecimal;
  exports.toSnapshot = toSnapshot;
  exports.toUnits = toUnits;
  exports.transformScale = transformScale;
  exports.trimScale = trimScale;
  exports.up = up;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.development.js.map
